# ðŸ§  Aegis AI-Powered Self-Healing System

## Overview

The Aegis of Alderaan now features an advanced AI-powered self-healing system that uses **Gemini 2.0 Flash** and **Neo4j graph database** to provide intelligent node analysis, mirror recommendations, and autonomous healing strategies.

## ðŸ”‘ Key Features

### 1. **Intelligent Health Analysis**

- AI-powered analysis of node health using system metrics, error logs, and anomalies
- Root cause identification with confidence scoring
- Recovery time estimation
- Immediate action recommendations

### 2. **Smart Mirror Management**

- Graph database-based mirror relationships
- AI recommendations for mirror activation
- Risk assessment for mirror transitions
- Automated failover strategies

### 3. **Autonomous Healing Strategies**

- Step-by-step healing plans generated by AI
- Phase-based recovery processes
- Rollback triggers and safety measures
- Success criteria monitoring

### 4. **Predictive Failure Detection**

- Historical pattern analysis
- Early warning systems
- Trending metric identification
- Proactive intervention recommendations

## ðŸ“¡ API Endpoints

### Health Analysis

```http
POST /ai/analyze/health/{agent_id}
```

**Description**: Analyze agent health using Gemini AI
**Response**:

```json
{
  "agent_id": "agent-001",
  "analysis": {
    "severity": "high",
    "root_cause": "High CPU utilization and memory leaks detected",
    "healing_strategy": "Restart services and optimize resource allocation",
    "mirror_recommendation": "should_activate",
    "estimated_recovery_time": 15,
    "confidence_score": 0.85,
    "immediate_actions": ["Restart Apache service", "Clear memory cache"],
    "preventive_measures": ["Enable memory monitoring", "Set up log rotation"]
  },
  "timestamp": "2024-01-15T10:30:00Z",
  "ai_enabled": true
}
```

### Mirror Recommendation

```http
POST /ai/mirror/recommend/{agent_id}
```

**Description**: Get AI recommendation for mirror activation
**Response**:

```json
{
  "agent_id": "agent-001",
  "recommendation": {
    "should_activate_mirror": true,
    "mirror_node_id": "agent-mirror-001",
    "transition_strategy": "gradual",
    "rollback_conditions": ["Primary node recovery", "Mirror overload"],
    "risk_assessment": "low"
  },
  "available_mirrors": [
    {
      "agent_id": "agent-mirror-001",
      "hostname": "mirror-server-1",
      "status": "active",
      "cpu_percent": 35.2,
      "memory_percent": 42.1
    }
  ],
  "timestamp": "2024-01-15T10:30:00Z"
}
```

### Healing Strategy Generation

```http
POST /ai/healing/strategy/{agent_id}
```

**Description**: Generate comprehensive healing strategy
**Response**:

```json
{
  "agent_id": "agent-001",
  "health_analysis": {
    /* Health analysis data */
  },
  "healing_strategy": {
    "strategy_id": "healing_20240115_103000",
    "priority": "urgent",
    "phases": [
      {
        "phase": "immediate_stabilization",
        "actions": ["Stop failing processes", "Clear cache"],
        "expected_duration": 5,
        "success_criteria": ["Processes stopped", "Memory freed"]
      },
      {
        "phase": "root_cause_resolution",
        "actions": ["Update configuration", "Restart services"],
        "expected_duration": 10,
        "success_criteria": ["Services running", "No errors"]
      }
    ],
    "monitoring_points": ["cpu_usage", "memory_usage", "error_rate"],
    "rollback_triggers": ["Service failure", "Performance degradation"],
    "estimated_total_time": 15
  },
  "timestamp": "2024-01-15T10:30:00Z"
}
```

### Mirror Activation

```http
POST /ai/mirror/activate/{agent_id}
```

**Description**: Activate mirror based on AI recommendation
**Response**:

```json
{
  "agent_id": "agent-001",
  "action": "mirror_activated",
  "mirror_agent": "agent-mirror-001",
  "strategy": "gradual",
  "ai_recommendation": {
    /* Recommendation details */
  },
  "timestamp": "2024-01-15T10:30:00Z"
}
```

### Failure Prediction

```http
POST /ai/predict/failure/{agent_id}
```

**Description**: Predict potential failures using historical data
**Response**:

```json
{
  "agent_id": "agent-001",
  "prediction": {
    "risk_level": "medium",
    "confidence": 0.72,
    "time_to_failure": "2.5 hours",
    "failure_indicators": ["Memory growth trend", "Error rate increase"],
    "trending_metrics": ["memory_up", "cpu_stable"],
    "recommended_actions": ["Monitor memory", "Schedule maintenance"]
  },
  "historical_data_points": 100,
  "timestamp": "2024-01-15T10:30:00Z"
}
```

### Mirror Topology with AI Analysis

```http
GET /ai/mirror/topology
```

**Description**: Get comprehensive mirror topology with AI analysis
**Response**:

```json
{
  "mirror_topology": {
    "agent-001": {
      "primary_info": {
        "agent_id": "agent-001",
        "hostname": "server-1",
        "status": "degraded"
      },
      "mirrors": [
        {
          "agent_id": "agent-mirror-001",
          "hostname": "mirror-server-1",
          "status": "active",
          "mirror_type": "active",
          "priority": 1
        }
      ],
      "ai_health_analysis": {
        "severity": "medium",
        "root_cause": "High disk usage",
        "confidence_score": 0.78
      }
    }
  },
  "total_primary_nodes": 5,
  "ai_analysis_enabled": true,
  "timestamp": "2024-01-15T10:30:00Z"
}
```

### Active Healing Processes

```http
GET /ai/healing/processes
```

**Description**: Get all active AI-initiated healing processes
**Response**:

```json
{
  "active_processes": [
    {
      "healing_id": "heal-001",
      "failed_agent": "agent-001",
      "healing_agent": "agent-mirror-001",
      "started_at": 1642248600000,
      "last_updated": 1642248900000
    }
  ],
  "count": 1,
  "timestamp": "2024-01-15T10:30:00Z"
}
```

## ðŸ›  Configuration

### Environment Variables

```bash
# Gemini AI Configuration
GEMINI_API_KEY=your_gemini_api_key_here

# Neo4j Configuration (for graph database)
NEO4J_URI=neo4j+s://your-database.databases.neo4j.io
NEO4J_USER=neo4j
NEO4J_PASSWORD=your_password

# MongoDB Configuration
MONGODB_URI=mongodb://localhost:27017
MONGODB_DATABASE=aegis_db
```

### Docker Configuration

The enhanced Dockerfile includes Gemini AI support:

```dockerfile
# Install AI dependencies
RUN pip install google-generativeai
```

## ðŸ”„ Integration Workflow

### 1. **Health Monitoring**

```python
# Continuous health monitoring
agent_data = await mongo_handler.get_agent(agent_id)
health_analysis = await gemini_ai.analyze_node_health(agent_data)

if health_analysis.severity in ['critical', 'high']:
    # Trigger healing process
    strategy = await gemini_ai.generate_healing_strategy(agent_data, health_analysis)
```

### 2. **Mirror Decision Making**

```python
# Get mirror recommendation
mirror_health = await neo4j_handler.check_mirror_health(agent_id)
available_mirrors = await get_available_mirrors(agent_id)
recommendation = await gemini_ai.get_mirror_recommendation(mirror_health, available_mirrors)

if recommendation.should_activate_mirror:
    await neo4j_handler.activate_mirror(agent_id, recommendation.mirror_node_id)
```

### 3. **Graph Database Integration**

```cypher
// Neo4j queries for mirror relationships
MATCH (p:Agent)-[r:HAS_MIRROR]->(m:Agent)
WHERE p.agent_id = $agent_id
RETURN m.agent_id, r.priority, r.mirror_type
ORDER BY r.priority
```

## ðŸ§ª Testing AI Features

### 1. **Health Analysis Test**

```bash
curl -X POST http://localhost:3001/ai/analyze/health/agent-001
```

### 2. **Mirror Recommendation Test**

```bash
curl -X POST http://localhost:3001/ai/mirror/recommend/agent-001
```

### 3. **Healing Strategy Test**

```bash
curl -X POST http://localhost:3001/ai/healing/strategy/agent-001
```

## ðŸ“Š WebSocket Events

The AI system sends real-time updates via WebSocket:

### Mirror Activation Event

```json
{
  "type": "mirror_activated",
  "data": {
    "primary_agent": "agent-001",
    "mirror_agent": "agent-mirror-001",
    "strategy": "gradual",
    "timestamp": "2024-01-15T10:30:00Z"
  }
}
```

### Health Analysis Event

```json
{
  "type": "ai_health_analysis",
  "data": {
    "agent_id": "agent-001",
    "severity": "high",
    "recommendation": "activate_mirror",
    "timestamp": "2024-01-15T10:30:00Z"
  }
}
```

## ðŸš€ Frontend Integration

### React Component Example

```jsx
import React, { useState } from "react";

const AIHealthMonitor = ({ agentId }) => {
  const [analysis, setAnalysis] = useState(null);
  const [loading, setLoading] = useState(false);

  const analyzeHealth = async () => {
    setLoading(true);
    try {
      const response = await fetch(`/api/ai/analyze/health/${agentId}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
      });
      const data = await response.json();
      setAnalysis(data.analysis);
    } catch (error) {
      console.error("Health analysis failed:", error);
    } finally {
      setLoading(false);
    }
  };

  const activateMirror = async () => {
    try {
      const response = await fetch(`/api/ai/mirror/activate/${agentId}`, {
        method: "POST",
      });
      const result = await response.json();
      console.log("Mirror activation result:", result);
    } catch (error) {
      console.error("Mirror activation failed:", error);
    }
  };

  return (
    <div className="ai-health-monitor">
      <h3>AI Health Monitor - {agentId}</h3>

      <button onClick={analyzeHealth} disabled={loading}>
        {loading ? "Analyzing..." : "Analyze Health"}
      </button>

      {analysis && (
        <div className="analysis-result">
          <div className={`severity ${analysis.severity}`}>
            Severity: {analysis.severity}
          </div>
          <div className="root-cause">Root Cause: {analysis.root_cause}</div>
          <div className="confidence">
            Confidence: {(analysis.confidence_score * 100).toFixed(1)}%
          </div>

          {analysis.mirror_recommendation === "should_activate" && (
            <button onClick={activateMirror} className="activate-mirror">
              Activate Mirror
            </button>
          )}

          <div className="immediate-actions">
            <h4>Immediate Actions:</h4>
            <ul>
              {analysis.immediate_actions.map((action, index) => (
                <li key={index}>{action}</li>
              ))}
            </ul>
          </div>
        </div>
      )}
    </div>
  );
};

export default AIHealthMonitor;
```

### CSS Styling

```css
.ai-health-monitor {
  border: 1px solid #ddd;
  border-radius: 8px;
  padding: 20px;
  margin: 10px;
  background: #f9f9f9;
}

.severity.critical {
  color: #d32f2f;
}
.severity.high {
  color: #f57c00;
}
.severity.medium {
  color: #fbc02d;
}
.severity.low {
  color: #388e3c;
}

.activate-mirror {
  background: #1976d2;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
  margin: 10px 0;
}

.immediate-actions ul {
  list-style-type: disc;
  margin-left: 20px;
}
```

## ðŸ”’ Security Considerations

1. **API Authentication**: All AI endpoints require valid JWT tokens
2. **Rate Limiting**: Implement rate limiting for AI API calls
3. **Input Validation**: Validate all agent IDs and parameters
4. **Error Handling**: Graceful degradation when AI services are unavailable

## ðŸ“ˆ Performance Optimization

1. **Caching**: Cache AI analysis results for frequently checked agents
2. **Async Processing**: All AI operations are non-blocking
3. **Fallback Systems**: Traditional rule-based analysis when AI is unavailable
4. **Resource Management**: Monitor Gemini API usage and costs

## ðŸ§© Extensibility

The AI system is designed to be extensible:

1. **Custom Prompts**: Modify prompts for specific use cases
2. **Additional Models**: Support for other AI models
3. **Plugin Architecture**: Add custom analysis modules
4. **Integration Points**: Connect with external monitoring systems

## ðŸŽ¯ Best Practices

1. **Monitor AI Confidence**: Only act on high-confidence recommendations
2. **Human Oversight**: Maintain manual override capabilities
3. **Gradual Rollout**: Test AI features in staging before production
4. **Continuous Learning**: Collect feedback to improve AI accuracy
5. **Cost Management**: Monitor Gemini API usage and optimize requests

## ðŸš¨ Troubleshooting

### Common Issues

1. **Gemini API Key Not Set**

   - Error: "GEMINI_API_KEY not found"
   - Solution: Set the environment variable correctly

2. **Neo4j Connection Failed**

   - Error: "Neo4j not available"
   - Solution: Check Neo4j connection settings and credentials

3. **AI Analysis Timeout**

   - Error: Request timeout
   - Solution: Increase timeout settings or check API limits

4. **Low Confidence Scores**
   - Issue: AI providing uncertain recommendations
   - Solution: Provide more historical data and context

### Debug Mode

Enable debug logging:

```python
logging.getLogger('gemini_ai_handler').setLevel(logging.DEBUG)
```

This comprehensive AI-powered self-healing system provides intelligent, autonomous network protection using cutting-edge AI technology combined with graph database insights for optimal decision-making and system resilience.
